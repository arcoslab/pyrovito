#!/usr/bin/env python
# Copyright (c) 2012 Technische Universitaet Muenchen, Informatik Lehrstuhl IX.
# Author: Federico Ruiz-Ugalde <memeruiz@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

#This modules creates a robot kinematic viewer plus some simple objects.
#this module uses the config files from the arms and the kinematic description from the hand_cartesian to create the visual representation.
#It uses the hand module from hand_cartesian to get the hand and finger's data, and uses the arm handler helper to get the data from the arm.
#in the objects:i port one can add simple visual objects and later change it's color, pose, and other properties

#Example of objects:i :
#(0 type sphere)
#(0 timeout -1)
#(0 trans 3 3 3)
#(0 trans 0.3 0.3 0.3)
#(0 color 0 1 0)
#(0 color 1 0 0))
#(0 color 1 0 0)
#format : (id property_name property_values)
# property values depend on the property_name
from avispy.objects_lib import Arrow, Sphere, Disk, Bar, Frame, Articulated, Articulated_tree, Cylinder, Triangle_3D, Framed_face, Framed_sphere, Framed_box
from avispy.engine import Camera,Display,Colors,Scene, Light
import numpy as _n
import numpy.linalg as _ln
import time
import pygame
import sys, signal
sys.path.append("../hand_cart")
sys.path.append("../config_data/lwr")

def configParse(argv):
    import optparse
    optparse.SUPPRESS_HELP
    import sys
    import os
    sim=False
    parser=optparse.OptionParser("usage: %prog [options]", add_help_option=False)
    parser.add_option("-e", "--help", action="help")
    parser.add_option("-w", "--width", dest="width", default="1280", type="int", help="Width")
    parser.add_option("-h", "--height", dest="height", default="720", type="int", help="Height")
    parser.add_option("--capture_dir", dest="capture_dir", default="./", type="string", help="capture directory")
    parser.add_option("--portbasename", dest="portbasename", default="myvis", type="string", help="Yarp port base name")
    parser.add_option("-c", action="store_true", dest="capture", default=False, help="Enable image capture")
    (options, args)= parser.parse_args(argv[1:])
    return (options, args)

options,args=configParse(sys.argv)

camera=Camera()
size=options.width,options.height
scene=Scene()
if options.capture:
    display=Display(camera,scene,res=size,image_dump_dir=options.capture_dir)
else:
    display=Display(camera,scene,res=size,image_dump_dir="")


light0=Light(Light.LIGHTS[0])
light0.position=_n.array([10.,10.,10.,1.0])
scene.add_light(light0)

light1=Light(Light.LIGHTS[1])
light1.position=_n.array([-10.,10.,10.,1.0])
scene.add_light(light1)

light2=Light(Light.LIGHTS[2])
light2.position=_n.array([0.,-10.,10.,1.0])
scene.add_light(light2)

light3=Light(Light.LIGHTS[3])
light3.position=_n.array([0.,0.,-10.,1.0])
scene.add_light(light3)


#camera center object
camera_center=Disk()
camera_center.set_color(_n.array([0.5,0.5,0.5]))
camera_center.set_color_reflex(_n.array([1.,1.,1.]),50.0)
camera_center.visibility=False
scene.add_object(camera_center)

world_frame=Frame()
world_frame.scale=_n.array([0.3,0.3,0.3])
scene.add_object(world_frame)

import yarp
yarpbaseportname="/"+options.portbasename+"/roboviewer"
yarp.Network.init()

#objects port
objects_port=yarp.BufferedPortBottle()
objects_port.open(yarpbaseportname+"/objects:i")
objects_port.setStrict()
objects_dict={}

from arcospyu.config_parser.config_parser import import_config

def terminate_handler(signum,stack_frame):
    print "Catched signal", signum
    yarp.Network.fini()
    sys.exit()

signal.signal(signal.SIGTERM,terminate_handler)
signal.signal(signal.SIGINT,terminate_handler)

import time
from arcospyu.control.control_loop import Controlloop

class My_loop(Controlloop):
    def set_params(self,params):
        pass

    def process(self):
        for event in pygame.event.get():
            #print event
            if event.type == pygame.QUIT or\
                   (event.type ==pygame.KEYDOWN and event.key == pygame.K_q):
                terminate_handler(signal.SIGTERM,None)
            #camera events:
            if event.type == pygame.MOUSEMOTION or \
                   event.type ==pygame.MOUSEBUTTONDOWN or \
                   event.type == pygame.MOUSEBUTTONUP:
                camera.update(event)
                camera.camera_matrix.get_frame() #TODO, this is done twice innecessarly
                val=camera.camera_matrix.radius*0.01
                camera_center.set_pos(_ln.inv(camera.camera_matrix.center_rot_frame)[:,3][:3])
                camera_center.scale=[val,val,1.0]
                if event.type == pygame.MOUSEMOTION :
                    if event.buttons == (1,0,0) or event.buttons == (0,0,1):
                        camera_center.visibility=True
                if event.type == pygame.MOUSEBUTTONDOWN or event.type == pygame.MOUSEBUTTONUP:
                    if event.button == 4 or event.button ==5:
                        camera_center.visibility=True
        #objects port processing
        while objects_port.getPendingReads()!=0:
            objects_bottle=objects_port.read(True)
            if objects_bottle:
                objects_bottles=map(yarp.Value.asList,map(objects_bottle.get,range(objects_bottle.size())))
                for object_bottle in objects_bottles:
                    object_id=object_bottle.get(0).asInt()
                    object_prop_name=object_bottle.get(1).toString()
                    if object_prop_name=="type":
                        object_prop_data=object_bottle.get(2).toString()
                    else:
                        object_prop_data=_n.array(map(yarp.Value.asDouble,map(object_bottle.get,range(object_bottle.size())[2:])))
                    #Properties are: type (sphere, frame, arrow, box), pose (16 values), color (three values), scale (three values),etc
                    if object_id in objects_dict:
                        #updating, adding property to object
                        if object_prop_name=="del":
                            scene.remove_object(objects_dict[object_id]["visid"])
                            del(objects_dict[object_id])
                            continue
                        else:
                            object_dict=objects_dict[object_id]
                            object_dict[object_prop_name]=object_prop_data
                    elif object_prop_name=="del":
                        print "Object doesn't exist"
                        continue
                    else:
                        #new object, creating
                        objects_dict[object_id]={object_prop_name: object_prop_data}
                        object_dict=objects_dict[object_id]
                        #print object_dict
                        if not "type" in object_dict:
                            object_dict["type"]="sphere"
                            object_dict["vis"]=Sphere()
                        else:
                            if object_dict["type"]=="sphere":
                                object_dict["vis"]=Sphere()
                            elif object_dict["type"]=="frame":
                                object_dict["vis"]=Frame()

                            ##daniel modification to add cylinders
                            elif object_dict["type"]=="cylinder":
                                object_dict["vis"]=Cylinder()
                            ##end daniel modification

                            elif object_dict["type"]=="arrow":
                                object_dict["vis"]=Arrow()
                            elif object_dict["type"]=="box":
                                object_dict["vis"]=Bar()
                            elif object_dict["type"]=="triangle3D":
                                object_dict["vis"]=Triangle_3D()
                            ##framed objects
                            elif object_dict["type"]=="framed_face":
                                object_dict["vis"]=Framed_face()

                            elif object_dict["type"]=="framed_sphere":
                                object_dict["vis"]=Framed_sphere()

                            elif object_dict["type"]=="framed_box":
                                object_dict["vis"]=Framed_box()
                        object_dict["visid"]=scene.add_object(object_dict["vis"])
                        if not "timeout" in object_dict:
                            object_dict["timeout"]=10.0
                    #resetting watchdog
                    objects_dict[object_id]["time"]=time.time()
                    #updating object
                    #for all objects:
                    if object_prop_name=="pose_offset" and "pose_offset" in objects_dict[object_id]:
                        #print "Pose", objects_dict[object_id]["vis"].trans_rot_matrix
                        print "hola"
                        objects_dict[object_id]["vis"].set_center_offset_matrix(objects_dict[object_id]["pose_offset"].reshape((4,4)))
                        print "hola2"
                    if "pose" in objects_dict[object_id]:
                        #print "Pose", objects_dict[object_id]["vis"].trans_rot_matrix
                        objects_dict[object_id]["vis"].trans_rot_matrix=objects_dict[object_id]["pose"].reshape((4,4))
                        #print "Pose", objects_dict[object_id]["vis"].trans_rot_matrix
                        if (object_prop_name=="pose") and ("trans" in objects_dict[object_id]):
                            del objects_dict[object_id]["trans"]
                        if (object_prop_name=="pose") and ("axis" in objects_dict[object_id]):
                            del objects_dict[object_id]["axis"]
                    if object_prop_name=="scale" and "scale" in objects_dict[object_id]:
                        objects_dict[object_id]["vis"].scale=objects_dict[object_id]["scale"]
                    if "color" in objects_dict[object_id]:
                        objects_dict[object_id]["vis"].set_color(objects_dict[object_id]["color"])
                    #for sphere
                    if "radius" in objects_dict[object_id]:
                        objects_dict[object_id]["vis"].set_radius(objects_dict[object_id]["radius"])
                    #for sphere and arrow
                    if "trans" in objects_dict[object_id]:
                        objects_dict[object_id]["vis"].set_pos(objects_dict[object_id]["trans"])
                        if (object_prop_name=="trans") and ("pose" in objects_dict[object_id]):
                            del objects_dict[object_id]["pose"]
                    #for arrow
                    if object_prop_name=="axis" and "axis" in objects_dict[object_id]:
                        objects_dict[object_id]["vis"].set_axis(objects_dict[object_id]["axis"])
                        if (object_prop_name=="trans") and ("pose" in objects_dict[object_id]):
                            del objects_dict[object_id]["pose"]
            #print objects_dict

        objects_to_remove=[]
        for object_id in objects_dict:
            if objects_dict[object_id]["timeout"]!=-1 and ((time.time()-objects_dict[object_id]["time"]) > objects_dict[object_id]["timeout"]):
                scene.remove_object(objects_dict[object_id]["visid"])
                objects_to_remove.append(object_id)
        for object_id in objects_to_remove:
            del(objects_dict[object_id])
        display.update()
        camera_center.visibility=False

loop=My_loop(15.)
loop.loop()
